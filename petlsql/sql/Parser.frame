#-------------------------------------------------------------------------
#Parser.py -- ATG file parser
#Compiler Generator Coco/R,
#Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
#extended by M. Loeberbauer & A. Woess, Univ. of Linz
#ported from Java to Python by Ronald Longo
#
#This program is free software; you can redistribute it and/or modify it
#under the terms of the GNU General Public License as published by the
#Free Software Foundation; either version 2, or (at your option) any
#later version.
#
#This program is distributed in the hope that it will be useful, but
#WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
#or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
#for more details.
#
#You should have received a copy of the GNU General Public License along
#with this program; if not, write to the Free Software Foundation, Inc.,
#59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
#As an exception, it is allowed to write an extension of Coco/R that is
#used as a plugin in non-free software.
#
#If not otherwise stated, any source code generated by Coco/R (other than
#Coco/R itself) does not fall under the GNU General Public License.
#-------------------------------------------------------------------------*/
-->begin

from . import ast
from .Scanner import *

import logging


class ErrorRec( object ):
    def __init__( self, l, c, s ):
        self.line   = l
        self.col    = c
        self.num    = 0
        self.str    = s


class Errors( object ):
    errMsgFormat = "file %(file)s : (%(line)d, %(col)d) %(text)s\n"
    #minErrDist   = 2
    #errDist      = minErrDist

    def __init__(self,fn):
        #eof          = False
        self.count    = 0         # number of errors detected
        self.fileName = fn

    def storeError(self, lvl, line, col, s ):
        print("%s[%d, %d]: %s" % (self.fileName, line, col, s))

    def SynErr(self, errNum, errPos=None ):
       line,col = errPos if errPos else self.getParsingPos( )
       self.storeError(logging.ERROR, line, col, self.errorMessages[ errNum ] )
       self.count += 1

    def SemErr(self, errMsg, errPos=None ):
       line,col = errPos if errPos else self.getParsingPos( )
       self.storeError(logging.ERROR, line, col, errMsg )
       self.count += 1

    def Warn(self, errMsg, errPos=None ):
       line,col = errPos if errPos else self.getParsingPos( )
       self.storeError(logging.WARNING, line, col, errMsg )


class Parser( object ):
-->constants
   T          = True
   x          = False
   minErrDist = 2

   -->declarations
   def __init__( self, filename, errors_class=Errors):
      self.scanner     = None
      self.token       = None           # last recognized token
      self.la          = None           # lookahead token
      self.genScanner  = False
      self.tokenString = ''             # used in declarations of literal tokens
      self.noString    = '-none-'       # used in declarations of literal tokens
      self.errDist     = Parser.minErrDist
      self.macroMode = False
      errs = self.errors = errors_class(filename)
      errs.getParsingPos = self.getParsingPos
      errs.errorMessages = Parser.errorMessages

   def getParsingPos( self ):
      return self.la.line, self.la.col

   def SynErr( self, errNum ):
      if self.errDist >= Parser.minErrDist:
         self.errors.SynErr( errNum )

      self.errDist = 0

   def SemErr( self, msg ):
      if self.errDist >= Parser.minErrDist:
         self.errors.SemErr( msg )

      self.errDist = 0

   def Warning( self, msg ):
      if self.errDist >= Parser.minErrDist:
         self.errors.Warn( msg )

      self.errDist = 0

   def Successful( self ):
      return self.errors.count == 0;

   def LexString( self ):
      return self.token.val

   def LookAheadString( self ):
      return self.la.val

   def Get( self ):
      while True:
         self.token = self.la
         self.la = self.scanner.Scan( )
         if self.la.kind <= Parser.maxT:
            self.errDist += 1
            break
         -->pragmas
         self.la = self.token

   def Expect( self, n ):
      if self.la.kind == n:
         self.Get( )
      else:
         self.SynErr( n )

   def StartOf( self, s ):
      return self.set[s][self.la.kind]

   def ExpectWeak( self, n, follow ):
      if self.la.kind == n:
         self.Get( )
      else:
         self.SynErr( n )
         while not self.StartOf(follow):
            self.Get( )

   def WeakSeparator( self, n, syFol, repFol ):
      s = [ False for i in xrange( Parser.maxT+1 ) ]
      if self.la.kind == n:
         self.Get( )
         return True
      elif self.StartOf(repFol):
         return False
      else:
         for i in xrange( Parser.maxT ):
            s[i] = self.set[syFol][i] or self.set[repFol][i] or self.set[0][i]
         self.SynErr( n )
         while not s[self.la.kind]:
            self.Get( )
         return self.StartOf( syFol )

   def getCasesensitiveTokenValue(self,token):
        p = token.pos
        return str(self.scanner.buffer.getSlice(p, p+len(token.val)))

-->productions

   def Parse( self, scanner ):
      self.scanner = scanner
      self.la = Token( )
      self.la.val = ''
      self.Get( )
      self.-->parseRoot

   set = [
-->initialization
      ]

   errorMessages = {
      -->errors
      }


$$$

